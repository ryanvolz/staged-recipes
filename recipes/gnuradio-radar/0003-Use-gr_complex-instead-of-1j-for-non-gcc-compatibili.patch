From bc12a5ba2f6d05111daf05f87eccffe8d6683648 Mon Sep 17 00:00:00 2001
From: Ryan Volz <rvolz@mit.edu>
Date: Mon, 1 Jun 2020 20:37:11 -0400
Subject: [PATCH 3/3] Use gr_complex() instead of 1j for non-gcc compatibility.

---
 lib/signal_generator_cw_c_impl.cc         |  4 ++--
 lib/signal_generator_fmcw_c_impl.cc       |  4 ++--
 lib/signal_generator_fsk_c_impl.cc        |  9 ++++-----
 lib/signal_generator_sync_pulse_c_impl.cc |  6 +++---
 lib/static_target_simulator_cc_impl.cc    | 15 +++++++--------
 5 files changed, 18 insertions(+), 20 deletions(-)

diff --git a/lib/signal_generator_cw_c_impl.cc b/lib/signal_generator_cw_c_impl.cc
index d9121f4..eccc893 100644
--- a/lib/signal_generator_cw_c_impl.cc
+++ b/lib/signal_generator_cw_c_impl.cc
@@ -87,9 +87,9 @@ int signal_generator_cw_c_impl::work(int noutput_items,
         for (int k = 0; k < d_num_freq; k++) { // Go through frequencies
             out[i] += d_amplitude / (float)d_num_freq *
                       exp(d_phase[k]); // output amplitude is normed on d_amplitude
-            d_phase[k] = 1j * std::fmod(imag(d_phase[k]) + 2 * GR_M_PI * d_frequency[k] /
+            d_phase[k] = gr_complex(0, std::fmod(imag(d_phase[k]) + 2 * GR_M_PI * d_frequency[k] /
                                                                (float)d_samp_rate,
-                                        2 * GR_M_PI);
+                                        2 * GR_M_PI));
         }
     }
 
diff --git a/lib/signal_generator_fmcw_c_impl.cc b/lib/signal_generator_fmcw_c_impl.cc
index 99e601a..774db92 100644
--- a/lib/signal_generator_fmcw_c_impl.cc
+++ b/lib/signal_generator_fmcw_c_impl.cc
@@ -97,9 +97,9 @@ int signal_generator_fmcw_c_impl::work(int noutput_items,
 
         // Write sample
         *out++ = d_amplitude * exp(d_phase);
-        d_phase = 1j * std::fmod(imag(d_phase) + 2 * GR_M_PI * d_waveform[d_wv_counter] /
+        d_phase = gr_complex(0, std::fmod(imag(d_phase) + 2 * GR_M_PI * d_waveform[d_wv_counter] /
                                                      (float)d_samp_rate,
-                                 2 * GR_M_PI);
+                                 2 * GR_M_PI));
         d_wv_counter++;
     }
 
diff --git a/lib/signal_generator_fsk_c_impl.cc b/lib/signal_generator_fsk_c_impl.cc
index debdaea..4234d11 100644
--- a/lib/signal_generator_fsk_c_impl.cc
+++ b/lib/signal_generator_fsk_c_impl.cc
@@ -109,12 +109,11 @@ int signal_generator_fsk_c_impl::work(int noutput_items,
         else
             out[i] = d_amplitude * exp(d_phase_low); // start with low_freq (state=0)
 
-        d_phase_low =
-            1j * std::fmod(imag(d_phase_low) + 2 * GR_M_PI * d_freq_low / (float)d_samp_rate,
-                           2 * GR_M_PI);
-        d_phase_high = 1j * std::fmod(imag(d_phase_high) +
+        d_phase_low = gr_complex(0, std::fmod(imag(d_phase_low) + 2 * GR_M_PI * d_freq_low / (float)d_samp_rate,
+                           2 * GR_M_PI));
+        d_phase_high = gr_complex(0, std::fmod(imag(d_phase_high) +
                                           2 * GR_M_PI * d_freq_high / (float)d_samp_rate,
-                                      2 * GR_M_PI);
+                                      2 * GR_M_PI));
     }
 
     // Tell runtime system how many output items we produced.
diff --git a/lib/signal_generator_sync_pulse_c_impl.cc b/lib/signal_generator_sync_pulse_c_impl.cc
index d4b3cd8..14f6484 100644
--- a/lib/signal_generator_sync_pulse_c_impl.cc
+++ b/lib/signal_generator_sync_pulse_c_impl.cc
@@ -71,20 +71,20 @@ signal_generator_sync_pulse_c_impl::signal_generator_sync_pulse_c_impl(
     while (pulse_wait < pulse_pause.size() || pulse_send < pulse_len.size()) {
         if (pulse_wait < pulse_pause.size()) { // Setup wait samples
             for (int p = 0; p < pulse_pause[pulse_wait]; p++)
-                d_out_buffer[k + p] = 0 + 1j * 0;
+                d_out_buffer[k + p] = gr_complex(0, 0);
             k += pulse_pause[pulse_wait];
             pulse_wait++;
         }
         if (pulse_send < pulse_len.size()) { // Setup pulse samples
             for (int p = 0; p < pulse_len[pulse_send]; p++)
-                d_out_buffer[k + p] = pulse_amplitude + 1j * 0;
+                d_out_buffer[k + p] = gr_complex(pulse_amplitude, 0);
             k += pulse_len[pulse_send];
             pulse_send++;
         }
     }
     if (k < packet_len) { // fill with zeros
         for (int p = 0; p < packet_len - k; p++) {
-            d_out_buffer[k + p] = 0 + 1j * 0;
+            d_out_buffer[k + p] = gr_complex(0, 0);
         }
     }
 }
diff --git a/lib/static_target_simulator_cc_impl.cc b/lib/static_target_simulator_cc_impl.cc
index 44fe2f9..302dbda 100644
--- a/lib/static_target_simulator_cc_impl.cc
+++ b/lib/static_target_simulator_cc_impl.cc
@@ -224,9 +224,9 @@ int static_target_simulator_cc_impl::work(int noutput_items,
                 // Doppler shift filter and rescaling amplitude with rcs
                 d_filt_doppler[k][i] = std::exp(d_phase_doppler) * d_scale_ampl[k];
                 d_phase_doppler =
-                    1j * std::fmod(std::imag(d_phase_doppler) +
+                    gr_complex(0, std::fmod(std::imag(d_phase_doppler) +
                                        2 * GR_M_PI * d_doppler[k] / (float)d_samp_rate,
-                                   2 * GR_M_PI); // integrate phase (with plus!)
+                                   2 * GR_M_PI)); // integrate phase (with plus!)
             }
 
             d_filt_time[k].resize(noutput_items);
@@ -234,9 +234,9 @@ int static_target_simulator_cc_impl::work(int noutput_items,
             for (int i = 0; i < noutput_items; i++) {
                 // Time shift filter, uses target range
                 d_phase_time =
-                    1j * std::fmod(2 * GR_M_PI * (d_timeshift[k]) // range time shift
+                    gr_complex(0, std::fmod(2 * GR_M_PI * (d_timeshift[k]) // range time shift
                                        * d_freq[i],
-                                   2 * GR_M_PI); // integrate phase (with minus!)
+                                   2 * GR_M_PI)); // integrate phase (with minus!)
                 d_filt_time[k][i] =
                     std::exp(-d_phase_time) /
                     (float)noutput_items; // div with noutput_item to correct amplitude
@@ -252,11 +252,10 @@ int static_target_simulator_cc_impl::work(int noutput_items,
                 for (int i = 0; i < noutput_items; i++) {
                     // Time shift filter, uses azimuth and RX position
                     d_phase_time =
-                        1j *
-                        std::fmod(2 * GR_M_PI *
+                        gr_complex(0, std::fmod(2 * GR_M_PI *
                                       (d_timeshift_azimuth[l][k]) // azimuth time shift
                                       * d_freq[i],
-                                  2 * GR_M_PI); // integrate phase (with minus!)
+                                  2 * GR_M_PI)); // integrate phase (with minus!)
                     d_filt_time_azimuth[l][k][i] =
                         std::exp(-d_phase_time); // do not div with noutput_items, is done
                                                  // with range timeshift filter
@@ -272,7 +271,7 @@ int static_target_simulator_cc_impl::work(int noutput_items,
     if (d_rndm_phaseshift) {
         gr_complex phase_random_hold;
         for (int k = 0; k < d_num_targets; k++) {
-            phase_random_hold = 1j * 2 * GR_M_PI * float((std::rand() % 1000 + 1) / 1000.0);
+            phase_random_hold = gr_complex(0, 2 * GR_M_PI * float((std::rand() % 1000 + 1) / 1000.0));
             d_phase_random = std::exp(phase_random_hold);
             std::fill_n(&d_filt_phase[k][0], noutput_items, d_phase_random);
         }
-- 
2.20.1

